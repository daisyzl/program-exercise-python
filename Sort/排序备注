堆排序→希尔排序→插入排序→计数排序→桶排序→合并排序→快排→选择排序→冒泡排序

分治算法
合并排序
快速排序

内存排序

插入排序：直接插入排序，希尔排序

选择排序：简单选择排序，堆排序

交换排序：冒泡排序，快速排序

合并排序

基数排序

一个算法中语句执行次数称为语句频度或时间频度 T(n)

计算1-100所有数字之和
int total = 0;
int end = 100;
for(int i=0, i<=end, i++)
	total += i;

T(n) = n+1
1表示最后一次计算i<=end

时间复杂度
由小到大O(1)<O(logn)<O(n)<O(nlogn)<O(n²)

常数阶O(1)
无论代码执行了多少行，只要是没有循环等复杂结构，代码的时间复杂度O(1)

O(logn)
假设循环x次之后，i就大于2，循环退出，2的x次方等于n
int i = 1;
while(i<n):
{
    i = i*2
}

O(n)
 for(int i=1; i<n; i++)
 {
 	j = i;
 	j++;
 }

 O(nlogn)
 将时间复杂度为O(logn)的代码循环n遍
 for(m=1; m<n; m++){
 	i = 1;
 	while(i<n){
 	 i= i*2
 	}
 }

 空间复杂度
 对算法在运行过程中临时占用存储空间大小的量度



